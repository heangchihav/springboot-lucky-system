spring.application.name=user-service
server.port=8081
app.spa.enabled=false
app.web.ui=disabled
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/user_service_db}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:postgres}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:postgres}
spring.datasource.driver-class-name=${SPRING_DATASOURCE_DRIVER_CLASS_NAME:org.postgresql.Driver}

# Optional JPA settings
# or: validate / create / create-drop
spring.jpa.hibernate.ddl-auto=update

spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Disable Liquibase to avoid conflicts with Hibernate DDL auto
spring.liquibase.enabled=false

# Trust proxy headers (for HTTPS behind reverse proxy)
server.forward-headers-strategy=framework

# ========== MILITARY-GRADE SECURITY CONFIGURATION ==========

# JWT Configuration
# IMPORTANT: Change this to a secure 256-bit key in production!
# Generate with: openssl rand -base64 32
security.jwt.secret=${JWT_SECRET:your-256-bit-secret-key-change-in-production-minimum-32-chars}
security.jwt.access-token-expiration-minutes=3
security.jwt.issuer=secure-app

# Refresh Token Configuration
security.refresh-token.expiration-days=7
security.refresh-token.max-devices=5

# HSTS Configuration (TLS 1.3 enforcement)
security.hsts.enabled=true
security.hsts.max-age-seconds=31536000

# Cookie Security
# Set to false for local development without HTTPS
security.cookie.secure=${COOKIE_SECURE:false}

# Origin/Referer Enforcement (CSRF hardening for cookie-authenticated APIs)
# Comma-separated list of allowed origins, e.g. https://test.mooniris.com
security.origin-check.enabled=true
security.origin-check.allowed-origins=${ALLOWED_ORIGINS:http://localhost:3000,https://test.mooniris.com,https://vetreport.vercel.app}

# Simple Application-Layer WAF (defense-in-depth)
security.waf.enabled=true
security.waf.max-content-length-bytes=1048576

# Brute Force Protection
security.brute-force.max-attempts=5
security.brute-force.lock-duration-minutes=15

# Token Blacklist (Redis)
security.blacklist.enabled=true

# Fail-Closed Mode (HIGH SECURITY)
# If true: if Redis (blacklist/JTI tracking) is unavailable, authentication fails.
security.fail-closed=${SECURITY_FAIL_CLOSED:false}

# JTI Tracking Configuration
security.jti.tracking-enabled=true
security.jti.max-per-device=2

# If true: suspicious JTI usage (e.g. IP prefix change) is rejected and the JTI is blacklisted.
security.jti.reject-suspicious=${SECURITY_JTI_REJECT_SUSPICIOUS:false}

# Redis Configuration
spring.data.redis.host=${REDIS_HOST:localhost}
spring.data.redis.port=${REDIS_PORT:6379}
spring.data.redis.password=${REDIS_PASSWORD:}
spring.data.redis.timeout=2000ms

spring.cache.type=redis
spring.cache.redis.use-key-prefix=true
spring.cache.redis.key-prefix=demo-cache:

# Session Configuration
server.servlet.session.timeout=30m
server.servlet.session.cookie.http-only=true
server.servlet.session.cookie.secure=${COOKIE_SECURE:false}
server.servlet.session.cookie.same-site=strict

management.endpoints.web.exposure.include=health,prometheus
management.endpoint.prometheus.enabled=true
management.metrics.export.prometheus.enabled=true