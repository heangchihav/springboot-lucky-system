pipeline {
    agent any
    
    parameters {
        choice(name: 'ENVIRONMENT', choices: ['dev', 'staging', 'prod'], description: 'Target environment')
        choice(name: 'SERVICE', choices: ['all', 'auth-server', 'gateway', 'call-service', 'delivery-service', 'marketing-service', 'branchreport-service', 'batch-service'], description: 'Service to build/deploy')
        booleanParam(name: 'SKIP_TESTS', defaultValue: false, description: 'Skip running tests')
        booleanParam(name: 'SKIP_BUILD', defaultValue: false, description: 'Skip build and only deploy')
        string(name: 'IMAGE_TAG', defaultValue: '', description: 'Docker image tag (empty = git commit SHA)')
        booleanParam(name: 'FORCE_DEPLOY', defaultValue: false, description: 'Force deployment even if no changes')
    }
    
    environment {
        DOCKER_REGISTRY = credentials('docker-registry-url')
        DOCKER_CREDENTIALS = credentials('docker-registry-credentials')
        KUBECONFIG = credentials('kubeconfig')
        IMAGE_TAG = "${params.IMAGE_TAG ?: env.GIT_COMMIT.take(8)}"
        DOCKER_BUILDKIT = '1'
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '20', artifactNumToKeepStr: '10'))
        timeout(time: 2, unit: 'HOURS')
        timestamps()
        disableConcurrentBuilds()
    }
    
    triggers {
        pollSCM('H/5 * * * *')
    }
    
    stages {
        stage('Preparation') {
            steps {
                script {
                    echo "üöÄ Starting Lucky System CI/CD Pipeline"
                    echo "üì¶ Service: ${params.SERVICE}"
                    echo "üåç Environment: ${params.ENVIRONMENT}"
                    echo "üè∑Ô∏è  Image Tag: ${env.IMAGE_TAG}"
                    echo "üîÄ Branch: ${env.BRANCH_NAME}"
                    
                    // Validate production deployment
                    if (params.ENVIRONMENT == 'prod' && env.BRANCH_NAME != 'main') {
                        error("‚ùå Production deployments only allowed from main branch")
                    }
                }
                
                cleanWs()
                checkout scm
                
                // Make scripts executable
                sh 'find . -name "*.sh" -type f -exec chmod +x {} \\;'
            }
        }
        
        stage('Build Services') {
            when { 
                not { params.SKIP_BUILD }
            }
            steps {
                script {
                    def services = params.SERVICE == 'all' ? 
                        ['auth-server', 'gateway', 'call-service', 'delivery-service', 'marketing-service', 'branchreport-service', 'batch-service'] :
                        [params.SERVICE]
                    
                    // Build in parallel for better performance
                    def buildStages = [:]
                    
                    services.each { service ->
                        buildStages["Build ${service}"] = {
                            stage("Build ${service}") {
                                dir(getServiceDir(service)) {
                                    buildService(service)
                                }
                            }
                        }
                    }
                    
                    parallel buildStages
                }
            }
        }
        
        stage('Test Services') {
            when { 
                not { params.SKIP_TESTS }
            }
            steps {
                script {
                    def services = params.SERVICE == 'all' ? 
                        ['auth-server', 'gateway', 'call-service', 'delivery-service', 'marketing-service', 'branchreport-service', 'batch-service'] :
                        [params.SERVICE]
                    
                    // Run tests in parallel
                    def testStages = [:]
                    
                    services.each { service ->
                        testStages["Test ${service}"] = {
                            stage("Test ${service}") {
                                dir(getServiceDir(service)) {
                                    testService(service)
                                }
                            }
                        }
                    }
                    
                    parallel testStages
                }
            }
        }
        
        stage('Build Docker Images') {
            when { 
                not { params.SKIP_BUILD }
            }
            steps {
                script {
                    def services = params.SERVICE == 'all' ? 
                        ['auth-server', 'gateway', 'call-service', 'delivery-service', 'marketing-service', 'branchreport-service', 'batch-service'] :
                        [params.SERVICE]
                    
                    // Build images in parallel
                    def imageStages = [:]
                    
                    services.each { service ->
                        imageStages["Build ${service} Image"] = {
                            stage("Build ${service} Image") {
                                dir(getServiceDir(service)) {
                                    buildDockerImage(service)
                                }
                            }
                        }
                    }
                    
                    parallel imageStages
                }
            }
        }
        
        stage('Push Docker Images') {
            when { 
                not { params.SKIP_BUILD }
            }
            steps {
                script {
                    def services = params.SERVICE == 'all' ? 
                        ['auth-server', 'gateway', 'call-service', 'delivery-service', 'marketing-service', 'branchreport-service', 'batch-service'] :
                        [params.SERVICE]
                    
                    // Push images in parallel
                    def pushStages = [:]
                    
                    services.each { service ->
                        pushStages["Push ${service} Image"] = {
                            stage("Push ${service} Image") {
                                pushDockerImage(service)
                            }
                        }
                    }
                    
                    parallel pushStages
                }
            }
        }
        
        stage('Deploy to Kubernetes') {
            steps {
                script {
                    def services = params.SERVICE == 'all' ? 
                        ['auth-server', 'gateway', 'call-service', 'delivery-service', 'marketing-service', 'branchreport-service', 'batch-service'] :
                        [params.SERVICE]
                    
                    // Deploy services (sequentially to maintain order)
                    services.each { service ->
                        stage("Deploy ${service}") {
                            deployToKubernetes(service)
                        }
                    }
                }
            }
        }
        
        stage('Health Check') {
            steps {
                script {
                    def services = params.SERVICE == 'all' ? 
                        ['auth-server', 'gateway', 'call-service', 'delivery-service', 'marketing-service', 'branchreport-service', 'batch-service'] :
                        [params.SERVICE]
                    
                    // Health check in parallel
                    def healthStages = [:]
                    
                    services.each { service ->
                        healthStages["Check ${service}"] = {
                            stage("Check ${service}") {
                                healthCheck(service)
                            }
                        }
                    }
                    
                    parallel healthStages
                }
            }
        }
    }
    
    post {
        always {
            // Clean up Docker resources
            sh 'docker system prune -f || true'
            
            // Archive test results
            script {
                try {
                    archiveArtifacts artifacts: '**/target/*.jar,**/target/surefire-reports/*.xml,**/target/dependency-check-report.html', fingerprint: true
                } catch (e) {
                    echo "No artifacts to archive: ${e.getMessage()}"
                }
            }
        }
        
        success {
            script {
                def deploymentUrl = getDeploymentUrl()
                
                emailext (
                    subject: "‚úÖ Deployment Successful - ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                    body: """
                        <h2>üéâ Deployment Successful</h2>
                        <p><strong>Service:</strong> ${params.SERVICE}</p>
                        <p><strong>Environment:</strong> ${params.ENVIRONMENT}</p>
                        <p><strong>Branch:</strong> ${env.BRANCH_NAME}</p>
                        <p><strong>Image Tag:</strong> ${env.IMAGE_TAG}</p>
                        <p><strong>Deployment URL:</strong> <a href="${deploymentUrl}">${deploymentUrl}</a></p>
                        <p><strong>Build Duration:</strong> ${currentBuild.durationString}</p>
                        <p><strong>Triggered by:</strong> ${env.BUILD_CAUSE}</p>
                    """,
                    to: "${env.CHANGE_AUTHOR_EMAIL ?: 'dev-team@company.com'}"
                )
            }
        }
        
        failure {
            emailext (
                subject: "‚ùå Deployment Failed - ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                body: """
                    <h2>‚ùå Deployment Failed</h2>
                    <p><strong>Service:</strong> ${params.SERVICE}</p>
                    <p><strong>Environment:</strong> ${params.ENVIRONMENT}</p>
                    <p><strong>Branch:</strong> ${env.BRANCH_NAME}</p>
                    <p><strong>Image Tag:</strong> ${env.IMAGE_TAG}</p>
                    <p><strong>Failed Stage:</strong> ${currentBuild.currentResult}</p>
                    <p><strong>Build Duration:</strong> ${currentBuild.durationString}</p>
                    <p><strong>View Build:</strong> <a href="${env.BUILD_URL}">${env.BUILD_URL}</a></p>
                """,
                to: "${env.CHANGE_AUTHOR_EMAIL ?: 'dev-team@company.com'}"
            )
        }
    }
}

// Helper functions
def getServiceDir(service) {
    def serviceDirs = [
        'auth-server': '../../backend/infrastructure/auth-server',
        'gateway': '../../backend/infrastructure/gateway',
        'call-service': '../../backend/services/call-service',
        'delivery-service': '../../backend/services/delivery-service',
        'marketing-service': '../../backend/services/marketing-service',
        'branchreport-service': '../../backend/services/branchreport-service',
        'batch-service': '../../backend/services/batch-service'
    ]
    
    return serviceDirs[service] ?: "../../backend/services/${service}"
}

def buildService(service) {
    echo "üî® Building ${service}..."
    
    if (service == 'branchreport-service') {
        sh 'cargo check'
    } else {
        sh './mvnw clean compile -DskipTests'
    }
}

def testService(service) {
    echo "üß™ Testing ${service}..."
    
    if (service == 'branchreport-service') {
        sh 'cargo test'
        publishTestResults testResultsPattern: 'target/test-results/**/*.xml'
    } else {
        sh './mvnw test'
        junit 'target/surefire-reports/*.xml'
        publishTestResults testResultsPattern: 'target/surefire-reports/*.xml'
    }
}

def buildDockerImage(service) {
    echo "üê≥ Building Docker image for ${service}..."
    
    def imageName = "${env.DOCKER_REGISTRY}/${service}:${env.IMAGE_TAG}"
    
    script {
        docker.build(imageName, ".")
    }
}

def pushDockerImage(service) {
    echo "üì§ Pushing Docker image for ${service}..."
    
    def imageName = "${env.DOCKER_REGISTRY}/${service}:${env.IMAGE_TAG}"
    
    script {
        docker.withRegistry("https://${env.DOCKER_REGISTRY}", 'docker-registry-credentials') {
            docker.image(imageName).push()
            docker.image(imageName).push('latest')
        }
    }
}

def deployToKubernetes(service) {
    echo "‚ò∏Ô∏è  Deploying ${service} to Kubernetes (deployment-only)..."
    
    script {
        def namespace = "demo-${params.ENVIRONMENT}"
        def image = "${env.DOCKER_REGISTRY}/${service}:${env.IMAGE_TAG}"
        def k8sDir = "${env.WORKSPACE}/devops/jenkins"
        
        // Use deployment-only script (no duplication)
        sh """
            cd ${k8sDir}
            chmod +x scripts/deploy-to-k8s.sh
            ./scripts/deploy-to-k8s.sh ${service} ${namespace} ${image}
        """
        
        echo "‚úÖ ${service} deployed successfully (no duplication)"
    }
}

def healthCheck(service) {
    echo "üè• Checking health of ${service} using existing K8s setup..."
    
    script {
        def namespace = "demo-${params.ENVIRONMENT}"
        def port = getServicePort(service)
        
        // Wait for pod to be ready using your existing deployment patterns
        sh """
            cd ${env.WORKSPACE}/devops/k8s
            
            # Wait for deployment to be ready
            kubectl wait --for=condition=available deployment/${service} -n ${namespace} --timeout=300s
            
            # Check health endpoint if port is available
            if command -v curl >/dev/null 2>&1; then
                kubectl port-forward -n ${namespace} svc/${service} ${port}:${port} &
                PF_PID=\$!
                sleep 10
                curl -f http://localhost:${port}/actuator/health || echo "Health check endpoint not available for ${service}"
                kill \$PF_PID 2>/dev/null || true
            fi
        """
        
        echo "‚úÖ ${service} health check passed"
    }
}

def getServicePort(service) {
    def ports = [
        'auth-server': '8081',
        'gateway': '8080',
        'call-service': '8082',
        'delivery-service': '8083',
        'marketing-service': '8084',
        'branchreport-service': '8085',
        'batch-service': '8086'
    ]
    
    return ports[service]
}

def getDeploymentUrl() {
    if (params.ENVIRONMENT == 'prod') {
        return "https://vetapi.mooniris.com"
    } else if (params.ENVIRONMENT == 'staging') {
        return "https://staging.vetapi.mooniris.com"
    } else {
        return "http://dev.vetapi.mooniris.com"
    }
}
